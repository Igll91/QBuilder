<?php
/**
 * Created by PhpStorm.
 * User: silvio
 * Date: 20.12.2016.
 * Time: 19:21
 */

namespace AppBundle\Model\Parser;

use AppBundle\Model\Filter\Filter;
use AppBundle\Model\Filter\FilterPairHolder;
use AppBundle\Model\Filter\Type\BooleanFilterType;
use AppBundle\Model\Filter\Type\DoubleFilterType;
use AppBundle\Model\Filter\Type\FilterType;
use AppBundle\Model\Filter\Type\IntegerFilterType;
use AppBundle\Model\Filter\Type\StringFilterType;
use AppBundle\Model\Operator\IsNotNullOperator;
use AppBundle\Model\Operator\IsNullOperator;
use AppBundle\Model\Operator\Operator;
use AppBundle\Model\Validator\Validator;
use AppBundle\Model\ValueHolder\AndConditionValueHolder;
use AppBundle\Model\ValueHolder\IValueHolder;
use AppBundle\Model\ValueHolder\OrConditionValueHolder;
use AppBundle\Model\ValueHolder\ValueHolder;

abstract class Parser
{
    /**
     * @var FilterPairHolder Holds available filters and their operators.
     */
    protected $filterPairHolder;

    public function __construct(FilterPairHolder $filterPairHolder)
    {
        $this->filterPairHolder = $filterPairHolder;
    }

    /**
     * Takes query generated from QueryBuilder frontend client and validates/generates values.
     *
     * Validates given query(with corresponding filter and operator) and brings it together into collection of IValueHolder.
     *
     * @see http://querybuilder.js.org/
     * @see OrConditionValueHolder
     * @see AndConditionValueHolder
     * @see ValueHolder
     *
     * @param string $query string Query generated by QueryBuilder frontend plugin.
     *
     * @return IValueHolder Value holder.
     */
    abstract public function parseQuery($query);

    protected function validateValue(Filter $filter, Operator $operator, $value)
    {
        $operatorClass = get_class($operator);

//      Validation is omitted, because value for these types is unnecessary in later processing.
        if ($operatorClass !== IsNullOperator::class && $operatorClass !== IsNotNullOperator::class) {
            $this->validateValueByFilterType($filter->getType(), $value);
            $this->validateValueByValidators($filter, $value);
        }
    }

    /**
     * Validate value with FilterType.
     *
     * @param FilterType $filterType FilterType to be used as validator.
     * @param  mixed     $value      Value to be validated.
     *
     * @see FilterType
     * @throws \InvalidArgumentException If value is not positively validated by FilterType.
     */
    private function validateValueByFilterType(FilterType $filterType, $value)
    {
        if (!$filterType->validateValue($value)) {
            throw new \InvalidArgumentException("FilterType [${filterType}] validation failed for value ${value}."); //Custom exception?
        }
    }

    /**
     * Validate value with all Filter validators.
     *
     * @see Validator
     *
     * @param Filter $filter Filter whose validators will be used if any.
     * @param mixed  $value  Value to be validated.
     *
     * @throws \InvalidArgumentException If value is not positively validated by Validator.
     */
    private function validateValueByValidators(Filter $filter, $value)
    {
        foreach ($filter->getValidators() as $validator) {
            if (!$validator->validate($value)) {
                throw new \InvalidArgumentException("Validation for value ${value} failed at ${validator}"); //Custom exception?
            }
        }
    }

    /**
     * Cast given value/s to corresponding FilterType.
     *
     * All values received from QueryBuilder frontend client are of type string, with this function we cast them to
     * corresponding type.
     *
     * @see http://querybuilder.js.org/
     *
     * @param mixed      $value
     * @param FilterType $filterType
     *
     * @throws \InvalidArgumentException If given FilterType is not supported yet.
     * @return array|mixed Returns value/s casted to corresponding FilterType.
     */
    protected function matchValueToFilterType($value, FilterType $filterType)
    {
        $cast = function ($val) use ($filterType) {
            switch (get_class($filterType)) {
                case DoubleFilterType::class:
                    return (double)$val;
                case IntegerFilterType::class:
                    return (int)$val;
                case StringFilterType::class:
                    return (string)$val;
                case BooleanFilterType::class:
                    $strVal = strtolower((string)$val);

                    return (in_array($strVal, array("true", "1", "yes"), true));
                default:
                    throw new \InvalidArgumentException("Unsupported filter type ${filterType}.");
            }
        };

        if (is_array($value)) {
            return array_map($cast, $value);
        } else {
            return $cast($value);
        }
    }
}
